<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Unsafe as a Human-Assisted Type System</title>
  <meta name="description"
    content="">

  <link rel="stylesheet" href="/css/asciidoctor.css">
  <link rel="stylesheet" href="/css/asciidoctor-pygments.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
  <link rel="canonical" href="https://matklad.github.io//2019/07/25/unsafe-as-a-type-system.html">
  <link rel="alternate" type="application/rss+xml" title="matklad"
    href="https://matklad.github.io//feed.xml">
</head>

<body>
  <header>
    <a class="nav-link site-title" href="/">matklad</a>

    <nav class="site-nav">
      
      
      <a class="nav-link" href="/about/">About</a>
      
      
      
      
      
      
      
      <a class="nav-link" href="/resume/">Resume</a>
      
      
    </nav>
  </header>

  <main>
    <article>
<h1>Unsafe as a Human-Assisted Type System</h1>
<div class="paragraph">
<p>This is a short note about yet another way to look at Rust&#8217;s <code>unsafe</code>.</p>
</div>
<div class="paragraph">
<p>Today, an interesting <a href="https://github.com/rust-lang/rust/issues/62894">bug</a> was found in rustc, which made me aware just how useful <code>unsafe</code> is for making code maintainable.
The story begins a couple of months ago, when I was casually browsing through recent pull requests for <a href="http://github.com/rust-lang/rust/">rust-lang/rust</a>.
I was probably waiting for my code to compile at that moment :]
Anyway, a <a href="https://github.com/rust-lang/rust/pull/58061">pull request</a> caught my attention, and, while I was reading the diff, I noticed a usage of <code>unsafe</code>.
It looked roughly like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="rust"><span></span><span class="tok-k">fn</span> <span class="tok-nf">map_in_place</span><span class="tok-o">&lt;</span><span class="tok-n">T</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">F</span><span class="tok-o">&gt;</span><span class="tok-p">(</span><span class="tok-n">t</span><span class="tok-o">:</span><span class="tok-w"> </span><span class="tok-o">&amp;</span><span class="tok-k">mut</span><span class="tok-w"> </span><span class="tok-n">T</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">f</span><span class="tok-o">:</span><span class="tok-w"> </span><span class="tok-n">F</span><span class="tok-p">)</span><span class="tok-w"></span>
<span class="tok-k">where</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-n">F</span><span class="tok-o">:</span><span class="tok-w"> </span><span class="tok-nb">FnOnce</span><span class="tok-p">(</span><span class="tok-n">T</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">-&gt;</span><span class="tok-w"> </span><span class="tok-n">T</span><span class="tok-p">,</span><span class="tok-w"></span>
<span class="tok-p">{</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-k">unsafe</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">ptr</span><span class="tok-o">::</span><span class="tok-n">write</span><span class="tok-p">(</span><span class="tok-n">t</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">f</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">ptr</span><span class="tok-o">::</span><span class="tok-n">read</span><span class="tok-p">(</span><span class="tok-n">t</span><span class="tok-p">)));</span><span class="tok-w"> </span><span class="tok-p">}</span><span class="tok-w"></span>
<span class="tok-p">}</span><span class="tok-w"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function applies a <code>T -&gt; T</code> function to a <code>&amp;mut T</code> value, a-la <a href="https://crates.io/crates/take_mut"><code>take_mut</code></a> crate.</p>
</div>
<div class="paragraph">
<p>There is a safe way to do this in Rust, by temporary replacing the value with something useless (<a href="http://giphygifs.s3.amazonaws.com/media/MS0fQBmGGMaRy/giphy.gif">Jones&#8217;s trick</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="rust"><span></span><span class="tok-k">fn</span> <span class="tok-nf">map_in_place_safe</span><span class="tok-o">&lt;</span><span class="tok-n">T</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">F</span><span class="tok-o">&gt;</span><span class="tok-p">(</span><span class="tok-n">t</span><span class="tok-o">:</span><span class="tok-w"> </span><span class="tok-o">&amp;</span><span class="tok-k">mut</span><span class="tok-w"> </span><span class="tok-n">T</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">f</span><span class="tok-o">:</span><span class="tok-w"> </span><span class="tok-n">F</span><span class="tok-p">)</span><span class="tok-w"></span>
<span class="tok-k">where</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-n">F</span><span class="tok-o">:</span><span class="tok-w"> </span><span class="tok-nb">FnOnce</span><span class="tok-p">(</span><span class="tok-n">T</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">-&gt;</span><span class="tok-w"> </span><span class="tok-n">T</span><span class="tok-p">,</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-n">T</span><span class="tok-o">:</span><span class="tok-w"> </span><span class="tok-nb">Default</span><span class="tok-p">,</span><span class="tok-w"></span>
<span class="tok-p">{</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-kd">let</span><span class="tok-w"> </span><span class="tok-n">stolen_t</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">mem</span><span class="tok-o">::</span><span class="tok-n">replace</span><span class="tok-p">(</span><span class="tok-n">t</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">T</span><span class="tok-o">::</span><span class="tok-n">default</span><span class="tok-p">());</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-n">t</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">f</span><span class="tok-p">(</span><span class="tok-n">stolen_t</span><span class="tok-p">)</span><span class="tok-w"></span>
<span class="tok-p">}</span><span class="tok-w"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In <code>map_in_place</code> we don&#8217;t have a <code>T: Default</code> bound, so the trick is not applicable.
Instead, the function uses (<code>unsafe</code>) <code>ptr::read</code> to get an owned value out of a unique reference, and then uses <code>ptr::write</code> to store the new value back, without calling the destructor.</p>
</div>
<div class="paragraph">
<p>However, the code has a particular <code>unsafe</code> code smell: it calls user-supplied code (<code>f</code>) from within an <code>unsafe</code> block.
This is usually undesirable, because it makes reasoning about invariants harder: arbitrary code can do arbitrary unexpected things.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>In this particular case, "user code" is clearly visible: it is literally a user-supplied closure.
The problem is not always that obvious: for example, arbitrary code might hide behind an innocent-looking <code>&lt;</code> operator that is invoked on a generic <code>T: Ord</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>And, indeed, this function is unsound: if <code>f</code> panics and unwinds, the <code>t</code> value would be dropped twice!
The solution here (which I know from the <code>take_mut</code> crate) is to just abort the process if the closure panics.
Stern, but effective!</p>
</div>
<div class="paragraph">
<p>I felt really torn about bringing this issue up: clearly, inside the compiler we know what we are doing, and the error case seems extremely marginal.
Nevertheless, I did leave the comment, and the abort trick was implemented.</p>
</div>
<div class="paragraph">
<p>And guess what?
Today a bug report came in (<a href="https://github.com/rust-lang/rust/issues/62894">#62894</a>), demonstrating that closure does panic in some cases, and <code>rustc</code> aborts.
To be clear, the abort in this case <em>is a good thing</em>!
If rustc didn&#8217;t abort, it would be a use-after-free.</p>
</div>
<div class="paragraph">
<p>Note how cool is this: a casual code-reviewer was able to prevent a memory-safety issue by looking at just a single one-line function.
This was possible for two reasons:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The code was marked <code>unsafe</code> which made it stand out.</p>
</li>
<li>
<p>The safety reasoning was purely local: I didn&#8217;t need to understand the PR (or surrounding code) as a whole to reason about the <code>unsafe</code> block.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The last bullet point is especially interesting, because it is what makes type systems<sup>[1]</sup> in general effective in large-scale software development:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Checking types is a local (per-expression, per-function, per-module, depending on the language) procedure.
Every step is almost trivial: verify that sub-expressions have the right type and work out the result type.</p>
</li>
<li>
<p>Together, these local static checks guarantee a highly non-trivial global property:
during runtime, actual types of all the values match inferred static types of variables.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Rust&#8217;s <code>unsafe</code> is similar: if we verify every usage of <code>unsafe</code> (local property!) to be correct, then we guarantee that the program as a whole does not contain undefined behavior.</p>
</div>
<div class="paragraph">
<p>The devil is in the details, however, so the reality is slightly more nuanced.</p>
</div>
<div class="paragraph">
<p><em>First</em>, <code>unsafe</code> should be checked by humans, thus a human-assisted type system.
The problem with humans, however, is that they make mistakes all the time.</p>
</div>
<div class="paragraph">
<p><em>Second</em>, checking <code>unsafe</code> can involve a rather large chunk of code.
For example, if you implement <code>Vec</code>, you can (safely) write to its <code>length</code> field from anywhere in the defining module.
That means that correctness of <code>Deref</code> impl for <code>Vec</code> depends on the whole module.
Common wisdom says that the boundary for <code>unsafe</code> code is a module, but I would love to see a more precise characteristic.
For example, in <code>map_in_place</code> case it&#8217;s pretty clear that only a single function should be examined.
On the other hand, if <code>Vec</code>'s field are <code>pub(super)</code>, parent module should be scrutinized as well.</p>
</div>
<div class="paragraph">
<p><em>Third</em>, it&#8217;s trivial to make all <code>unsafe</code> blocks technically correct by just making every function <code>unsafe</code>.
That wouldn&#8217;t be a useful thing to do though!
Similarly, if <code>unsafe</code> is used willy-nilly across the ecosystem, its value is decreased, because there would be many incorrect <code>unsafe</code> blocks, and reviewing each additional block would be harder.</p>
</div>
<div class="paragraph">
<p><em>Fourth</em>, and probably most disturbing, correctness of two <code>unsafe</code> blocks in isolation <a href="http://smallcultfollowing.com/babysteps/blog/2016/10/02/observational-equivalence-and-unsafe-code/">does not guarantee</a> that they together are correct!
We shouldn&#8217;t panic though: in practice, realistic usages of <code>unsafe</code> do compose.</p>
</div>
<div class="paragraph">
<p>Discussion on <a href="https://www.reddit.com/r/rust/comments/chvl50/blog_post_unsafe_as_a_humanassisted_type_system/">r/rust</a>.</p>
</div>
<div class="paragraph">
<p>[1] <code>unsafe</code> is really an effect system, but the difference is not important here.</p>
</div>
</article>

  </main>

  <footer>
    <p class="about-text">Yet another programmer's blog</p>

    <p>
      <a href="/feed.xml" class="footer-link">
        <i class="fa fa-rss"></i> rss
      </a>

      <a class="footer-link" href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
